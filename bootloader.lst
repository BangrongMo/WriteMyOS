     1                                  HDDPORT equ 0x1f0
     2                                  SETCHAR equ 0x07
     3                                  VIDEOMEM equ 0xb800
     4                                  STRINGLEN equ 0xff
     5                                  NUL equ 0x00
     6                                  
     7                                  section code align=16 vstart=0x7c00
     8 00000000 B80300                  mov ax, 3
     9 00000003 CD10                    int 10h
    10 00000005 BE[DA00]                mov si, msg
    11 00000008 31FF                    xor di,di
    12 0000000A E8A400                  call PrintString
    13                                  
    14 0000000D 8B36[CF00]              mov si,[READSTART]
    15 00000011 8B0E[D100]              mov cx,[READSTART+0X02] ;存储lba28地址,需要四个字节,高位cx低位si
    16 00000015 A0[D300]                mov al,[SECTORNUM];要读入的扇区数量
    17 00000018 50                      push ax ;保存扇区值al,push 要用ax，所以一起ah保存了
    18                                  
    19 00000019 A1[D400]                mov ax,[DESTMEM]
    20 0000001C 8B16[D600]              mov dx,[DESTMEM+0X02]
    21 00000020 BB1000                  mov bx,16 ;因为DESTMEM是完整地址，除以16计算DESTMEM的段地址
    22 00000023 F7F3                    div bx
    23                                  
    24 00000025 8ED8                    mov ds,ax ;配置段地址
    25 00000027 31FF                    xor di,di ;偏移地址置0
    26 00000029 58                      pop ax
    27                                  
    28                                  
    29                                  
    30 0000002A E83F00                  call READHDD
    31                                  
    32                                  
    33                                  ;加载完program.bin后，里面编译好的段地址和偏移地址是不能直接用的，
    34                                  ;因为编译器是按照program作为第一个扇区的程序来设置地址的
    35                                  ;而bootloader实际上才是第一个扇区的，所以要重新计算program的段地址和偏移地址，
    36                                  ;并修改加载到内存的program，才能跳转到program执行
    37                                  ;mov ax, [1000h] 默认等价于 mov ax, [ds:1000h]
    38                                  ;jmp 1234h 那么跳转目标是 CS:1234h，在当前代码段中跳转。
    39                                  
    40                                  
    41                                  ResetSegment: ;？修改段地址到0x1000,即第二个扇区读入到内存的地址
    42 0000002D BB0400                  	mov bx,0x04 ;将program段地址所在的内存地址写入bx,地址来源于program.asm中CodeSeg dd section.code.start
    43 00000030 8A0E1000                	mov cl,[0x10] ;0x10地址存储了program有多少个段,方便后面作为循环次数 ds本来以及指向DESTMEM，所以直接取
    44                                  	
    45                                  	.reset:	
    46                                  	
    47 00000034 8B07                    	mov ax,[bx] ;取出段地址（其实是相对地址，[bx]存储的值是编译program.asm产生的，
    48                                  				;是独立的,之后和bootloader整合就要重新计算段和偏移）
    49 00000036 8B5702                  	mov dx,[bx+2]  ;由于地址是四个字节，取两次
    50                                  	
    51                                  	
    52                                  	;汇编代码中，从内存取数据的时候，是ds:偏移地址取值，段内代码跳转的时候是cs:偏移地址 。
    53                                  	;为了获得正确的段内偏移地址
    54                                  	;读programer程序的大小，因为是32位，读两次
    55                                  	;现在dx:ax是program初始CodeSeg地址，下面将重新计算
    56                                  	
    57                                  		
    58                                  	
    59                                  	;DESTMEM编译到了当前代码段（我需要从当前代码段（CS）中，偏移为 DESTMEM 的位置读取值）
    60                                  	;,DESTMEM的值要通过cs查找，告诉cpu
    61 00000039 2E0306[D400]            	add ax,[cs:DESTMEM]  ; cs:0xffff,内存值0x0000，前面取出了ax，将两者相加
    62 0000003E 2E1316[D600]            	adc dx,[cs:DESTMEM+2] ;内存值0x0001
    63 00000043 BE1000                  	mov si,16 ;0x0001_0020  >> 16  =  0x1002
    64 00000046 F7F6                    	div si
    65 00000048 8907                    	mov [bx],ax ;新的地址计算完成,重写到[0x04]处
    66                                  	
    67                                  	
    68                                  	
    69 0000004A 83C304                  	add bx,4 ;准备计算下一个
    70 0000004D E2E5                    	loop .reset
    71                                  	
    72                                  	ResetEntry:
    73 0000004F A11300                  	mov ax,[0x13] ;ax，所以取了13、14
    74 00000052 8B161500                	mov dx,[0x15] 
    75                                  
    76                                  	
    77 00000056 2E0306[D400]            	add ax,[cs:DESTMEM] ; 
    78 0000005B 2E0316[D600]            	add dx,[cs:DESTMEM+2] ;
    79 00000060 BE1000                  	mov si,16
    80 00000063 F7F6                    	div si  	;shr ax,4
    81                                  	
    82 00000065 A31300                  	mov [0x13],ax
    83                                  	
    84 00000068 FF2E1100                	jmp far [0x11] ;jmp far [address] 是通过该内存地址处的 4 字节（16位 offset + 16位 segment）作为目标。
    85                                  					;DESTMEM:0x11是入口地址
    86                                  	
    87                                  READHDD:
    88 0000006C 50                      	push ax
    89 0000006D 53                      	push bx
    90 0000006E 51                      	push cx
    91 0000006F 52                      	push dx
    92 00000070 BAF201                  	mov dx,HDDPORT+2
    93 00000073 EE                      	out dx,al ;al存储的扇区数,写到dx端口
    94                                  	
    95 00000074 BAF301                  	mov dx,HDDPORT+3 ;开始写地址
    96 00000077 89F0                    	mov ax,si ;lba28低位si写到ax
    97 00000079 EE                      	out dx,al ;写低位 0-7
    98                                  
    99 0000007A BAF401                  	mov dx,HDDPORT+4
   100 0000007D 88E0                    	mov al,ah
   101 0000007F EE                      	out dx,al ;写高位 8-15
   102                                  	
   103 00000080 BAF501                  	mov dx,HDDPORT+5
   104 00000083 89C8                    	mov ax,cx ;换一个寄存器赋值到ax,写低位 16-23
   105 00000085 EE                      	out dx,al
   106                                  	
   107 00000086 BAF601                  	mov dx,HDDPORT+6
   108 00000089 88E0                    	mov al,ah
   109 0000008B B4E0                    	mov ah,0xe0 ;采用lba模式读取
   110 0000008D 08E0                    	or al,ah
   111 0000008F EE                      	out dx,al ;写24-27位
   112                                  	
   113 00000090 BAF701                  	mov dx,HDDPORT+7
   114 00000093 B020                    	mov al,0x20 ;0x20为读模式,0x30为写模式
   115 00000095 EE                      	out dx,al
   116                                  	
   117                                  	.waits: ;自旋锁循环等待磁盘io可用
   118 00000096 EC                      	in al,dx
   119 00000097 2488                    	and al,0x88
   120 00000099 3C08                    	cmp al,0x08
   121 0000009B 75F9                    	jnz .waits
   122                                  	
   123 0000009D BAF001                  	mov dx, HDDPORT ;地址写完,dx挪作hddport使用
   124 000000A0 B90001                  	mov cx,256 ;每次可以读2字节，所以循环256读取一个扇区
   125                                  	
   126                                  	.readword:
   127 000000A3 ED                      	in ax,dx ;读取端口数据到ax
   128 000000A4 3E8905                  	mov [ds:di],ax ;存到内存
   129 000000A7 83C702                  	add di,2
   130                                  	;or ah,0x00 ;因为数据以0x00结尾，所以看到0x00就退出
   131                                  	;jnz .readword
   132 000000AA E2F7                    	loop .readword
   133                                  	.return:
   134 000000AC 5A                      	pop dx
   135 000000AD 59                      	pop cx
   136 000000AE 5B                      	pop bx
   137 000000AF 58                      	pop ax
   138 000000B0 C3                      	ret
   139                                  PrintString:
   140                                  	.setup:
   141 000000B1 B800B8                  	mov ax,VIDEOMEM
   142 000000B4 8EC0                    	mov es,ax
   143 000000B6 B707                    	mov bh,SETCHAR
   144 000000B8 B9FF00                  	mov cx,STRINGLEN 
   145                                  	
   146                                  	.printchar:
   147 000000BB 3E8A1C                  	mov bl,[ds:si]
   148 000000BE 46                      	inc si
   149 000000BF 26881D                  	mov [es:di],bl
   150 000000C2 47                      	inc di
   151 000000C3 26883D                  	mov [es:di],bh
   152 000000C6 47                      	inc di
   153 000000C7 80CB00                  	or bl,NUL
   154 000000CA 7402                    	jz .return
   155 000000CC E2ED                    	loop .printchar
   156                                  	.return:
   157 000000CE C3                      	ret
   158                                  	
   159                                  
   160 000000CF 01000000                READSTART  dd 1
   161 000000D3 01                      SECTORNUM  db 1
   162 000000D4 00000100                DESTMEM	   dd 0x10000
   163                                  
   164 000000D8 EBFE                    End: jmp End
   165 000000DA 6D6272206C6F616420-     msg db 'mbr load secucess,loading next sector... ',0
   165 000000E3 73656375636573732C-
   165 000000EC 6C6F6164696E67206E-
   165 000000F5 65787420736563746F-
   165 000000FE 722E2E2E2000       
   166 00000104 00<rep FAh>             times 510-($-$$) db 0 ; 填充剩余空间
   167 000001FE 55AA                    dw 0xAA55
