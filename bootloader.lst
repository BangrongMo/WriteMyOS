     1                                  HDDPORT equ 0x1f0
     2                                  SETCHAR equ 0x07
     3                                  VIDEOMEM equ 0xb800
     4                                  STRINGLEN equ 0xff
     5                                  NUL equ 0x00
     6                                  
     7                                  section code align=16 vstart=0x7c00
     8 00000000 B80300                  mov ax, 3
     9 00000003 CD10                    int 10h
    10                                  
    11 00000005 BE[DA00]                mov si, msg
    12 00000008 31FF                    xor di,di
    13 0000000A E8A400                  call PrintString
    14                                  
    15 0000000D 8B36[CF00]              mov si,[READSTART]
    16 00000011 8B0E[D100]              mov cx,[READSTART+0X02] ;存储lba28地址,需要四个字节,高位cx低位si
    17 00000015 A0[D300]                mov al,[SECTORNUM];要读入的扇区数量
    18 00000018 50                      push ax ;保存扇区值al,push 要用ax，所以一起ah保存了
    19                                  
    20 00000019 A1[D400]                mov ax,[DESTMEM]
    21 0000001C 8B16[D600]              mov dx,[DESTMEM+0X02]
    22 00000020 BB1000                  mov bx,16 ;因为DESTMEM是完整地址，除以16计算DESTMEM的段地址
    23 00000023 F7F3                    div bx
    24                                  
    25 00000025 8ED8                    mov ds,ax ;配置段地址
    26 00000027 31FF                    xor di,di ;偏移地址置0
    27 00000029 58                      pop ax
    28                                  
    29                                  
    30                                  
    31 0000002A E83F00                  call READHDD
    32                                  
    33                                  
    34                                  ;加载完program.bin后，里面编译好的段地址和偏移地址是不能直接用的，
    35                                  ;因为编译器是按照program作为第一个扇区的程序来设置地址的
    36                                  ;而bootloader实际上才是第一个扇区的，所以要重新计算program的段地址和偏移地址，
    37                                  ;并修改加载到内存的program，才能跳转到program执行
    38                                  ;mov ax, [1000h] 默认等价于 mov ax, [ds:1000h]
    39                                  ;jmp 1234h 那么跳转目标是 CS:1234h，在当前代码段中跳转。
    40                                  
    41                                  
    42                                  ResetSegment: ;？修改段地址到0x1000,即第二个扇区读入到内存的地址
    43 0000002D BB0400                  	mov bx,0x04 ;将program段地址所在的内存地址写入bx,地址来源于program.asm中CodeSeg dd section.code.start
    44 00000030 8A0E1000                	mov cl,[0x10] ;0x10地址存储了program有多少个段,方便后面作为循环次数 ds本来以及指向DESTMEM，所以直接取
    45                                  	
    46                                  	.reset:	
    47                                  	
    48 00000034 8B07                    	mov ax,[bx] ;取出段地址（其实是相对地址，[bx]存储的值是编译program.asm产生的，
    49                                  				;是独立的,之后和bootloader整合就要重新计算段和偏移）
    50 00000036 8B5702                  	mov dx,[bx+2]  ;由于地址是四个字节，取两次
    51                                  	
    52                                  	
    53                                  	;汇编代码中，从内存取数据的时候，是ds:偏移地址取值，段内代码跳转的时候是cs:偏移地址 。
    54                                  	;为了获得正确的段内偏移地址
    55                                  	;读programer程序的大小，因为是32位，读两次
    56                                  	;现在dx:ax是program初始CodeSeg地址，下面将重新计算
    57                                  	
    58                                  		
    59                                  	
    60                                  	;DESTMEM编译到了当前代码段（我需要从当前代码段（CS）中，偏移为 DESTMEM 的位置读取值）
    61                                  	;,DESTMEM的值要通过cs查找，告诉cpu
    62 00000039 2E0306[D400]            	add ax,[cs:DESTMEM]  ; cs:0xffff,内存值0x0000，前面取出了ax，将两者相加
    63 0000003E 2E1316[D600]            	adc dx,[cs:DESTMEM+2] ;内存值0x0001
    64 00000043 BE1000                  	mov si,16 ;0x0001_0020  >> 16  =  0x1002
    65 00000046 F7F6                    	div si
    66 00000048 8907                    	mov [bx],ax ;新的地址计算完成,重写到[0x04]处
    67                                  	
    68                                  	
    69                                  	
    70 0000004A 83C304                  	add bx,4 ;准备计算下一个
    71 0000004D E2E5                    	loop .reset
    72                                  	
    73                                  	ResetEntry:
    74 0000004F A11300                  	mov ax,[0x13] ;ax，所以取了13、14
    75 00000052 8B161500                	mov dx,[0x15] 
    76                                  
    77                                  	
    78 00000056 2E0306[D400]            	add ax,[cs:DESTMEM] ; 
    79 0000005B 2E0316[D600]            	add dx,[cs:DESTMEM+2] ;
    80 00000060 BE1000                  	mov si,16
    81 00000063 F7F6                    	div si  	;shr ax,4
    82                                  	
    83 00000065 A31300                  	mov [0x13],ax
    84                                  	
    85 00000068 FF2E1100                	jmp far [0x11] ;jmp far [address] 是通过该内存地址处的 4 字节（16位 offset + 16位 segment）作为目标。
    86                                  					;DESTMEM:0x11是入口地址
    87                                  	
    88                                  READHDD:
    89 0000006C 50                      	push ax
    90 0000006D 53                      	push bx
    91 0000006E 51                      	push cx
    92 0000006F 52                      	push dx
    93 00000070 BAF201                  	mov dx,HDDPORT+2
    94 00000073 EE                      	out dx,al ;al存储的扇区数,写到dx端口
    95                                  	
    96 00000074 BAF301                  	mov dx,HDDPORT+3 ;开始写地址
    97 00000077 89F0                    	mov ax,si ;lba28低位si写到ax
    98 00000079 EE                      	out dx,al ;写低位 0-7
    99                                  
   100 0000007A BAF401                  	mov dx,HDDPORT+4
   101 0000007D 88E0                    	mov al,ah
   102 0000007F EE                      	out dx,al ;写高位 8-15
   103                                  	
   104 00000080 BAF501                  	mov dx,HDDPORT+5
   105 00000083 89C8                    	mov ax,cx ;换一个寄存器赋值到ax,写低位 16-23
   106 00000085 EE                      	out dx,al
   107                                  	
   108 00000086 BAF601                  	mov dx,HDDPORT+6
   109 00000089 88E0                    	mov al,ah
   110 0000008B B4E0                    	mov ah,0xe0 ;采用lba模式读取
   111 0000008D 08E0                    	or al,ah
   112 0000008F EE                      	out dx,al ;写24-27位
   113                                  	
   114 00000090 BAF701                  	mov dx,HDDPORT+7
   115 00000093 B020                    	mov al,0x20 ;0x20为读模式,0x30为写模式
   116 00000095 EE                      	out dx,al
   117                                  	
   118                                  	.waits: ;自旋锁循环等待磁盘io可用
   119 00000096 EC                      	in al,dx
   120 00000097 2488                    	and al,0x88
   121 00000099 3C08                    	cmp al,0x08
   122 0000009B 75F9                    	jnz .waits
   123                                  	
   124 0000009D BAF001                  	mov dx, HDDPORT ;地址写完,dx挪作hddport使用
   125 000000A0 B90001                  	mov cx,256 ;每次可以读2字节，所以循环256读取一个扇区
   126                                  	
   127                                  	.readword:
   128 000000A3 ED                      	in ax,dx ;读取端口数据到ax
   129 000000A4 3E8905                  	mov [ds:di],ax ;存到内存
   130 000000A7 83C702                  	add di,2
   131                                  	;or ah,0x00 ;因为数据以0x00结尾，所以看到0x00就退出
   132                                  	;jnz .readword
   133 000000AA E2F7                    	loop .readword
   134                                  	.return:
   135 000000AC 5A                      	pop dx
   136 000000AD 59                      	pop cx
   137 000000AE 5B                      	pop bx
   138 000000AF 58                      	pop ax
   139 000000B0 C3                      	ret
   140                                  PrintString:
   141                                  	.setup:
   142 000000B1 B800B8                  	mov ax,VIDEOMEM
   143 000000B4 8EC0                    	mov es,ax
   144 000000B6 B707                    	mov bh,SETCHAR
   145 000000B8 B9FF00                  	mov cx,STRINGLEN 
   146                                  	
   147                                  	.printchar:
   148 000000BB 3E8A1C                  	mov bl,[ds:si]
   149 000000BE 46                      	inc si
   150 000000BF 26881D                  	mov [es:di],bl
   151 000000C2 47                      	inc di
   152 000000C3 26883D                  	mov [es:di],bh
   153 000000C6 47                      	inc di
   154 000000C7 80CB00                  	or bl,NUL
   155 000000CA 7402                    	jz .return
   156 000000CC E2ED                    	loop .printchar
   157                                  	.return:
   158 000000CE C3                      	ret
   159                                  	
   160                                  
   161 000000CF 01000000                READSTART  dd 1
   162 000000D3 01                      SECTORNUM  db 1
   163 000000D4 00000100                DESTMEM	   dd 0x10000
   164                                  
   165 000000D8 EBFE                    End: jmp End
   166 000000DA 6D6272206C6F616420-     msg db 'mbr load secucess,loading next sector... ',0
   166 000000E3 73656375636573732C-
   166 000000EC 6C6F6164696E67206E-
   166 000000F5 65787420736563746F-
   166 000000FE 722E2E2E2000       
   167 00000104 00<rep FAh>             times 510-($-$$) db 0 ; 填充剩余空间
   168 000001FE 55AA                    dw 0xAA55
