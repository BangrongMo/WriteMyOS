     1                                  HDDPORT equ 0x1f0
     2                                  section code align=16 vstart=0x7c00
     3 00000000 8B36[B100]              mov si,[READSTART]
     4 00000004 8B0E[B300]              mov cx,[READSTART+0X02] ;存储lba28地址,需要四个字节,高位cx低位si
     5 00000008 A0[B500]                mov al,[SECTORNUM];要读入的扇区数量
     6 0000000B 50                      push ax ;保存扇区值al,push 要用ax，所以一起ah保存了
     7                                  
     8 0000000C A1[B600]                mov ax,[DESTMEM]
     9 0000000F 8B16[B800]              mov dx,[DESTMEM+0X02]
    10 00000013 BB1000                  mov bx,16 ;因为DESTMEM是完整地址，除以16计算DESTMEM的段地址
    11 00000016 F7F3                    div bx
    12                                  
    13 00000018 8ED8                    mov ds,ax ;配置段地址
    14 0000001A 31FF                    xor di,di ;偏移地址置0
    15 0000001C 58                      pop ax
    16                                  
    17                                  ;mov si, msg
    18                                  
    19 0000001D E84C00                  call READHDD
    20                                  
    21                                  
    22                                  ;加载完program.bin后，里面编译好的段地址和偏移地址是不能直接用的，
    23                                  ;因为编译器是按照program作为第一个扇区的程序来设置地址的
    24                                  ;而bootloader实际上才是第一个扇区的，所以要重新计算program的段地址和偏移地址，
    25                                  ;并修改加载到内存的program，才能跳转到program执行
    26                                  ;mov ax, [1000h] 默认等价于 mov ax, [ds:1000h]
    27                                  ;jmp 1234h 那么跳转目标是 CS:1234h，在当前代码段中跳转。
    28                                  
    29                                  
    30                                  ResetSegment: ;？修改段地址到0x1000,即第二个扇区读入到内存的地址
    31 00000020 BB0400                  	mov bx,0x04 ;将program段地址所在的内存地址写入bx,地址来源于program.asm中CodeSeg dd section.code.start
    32 00000023 8A0E1000                	mov cl,[0x10] ;0x10地址存储了program有多少个段,方便后面作为循环次数 ds本来以及指向DESTMEM，所以直接取
    33                                  	
    34                                  	.reset:	
    35                                  	
    36 00000027 8B07                    	mov ax,[bx] ;取出段地址（其实是相对地址，[bx]存储的值是编译program.asm产生的，
    37                                  				;是独立的,之后和bootloader整合就要重新计算段和偏移）
    38 00000029 8B5702                  	mov dx,[bx+2]  ;由于地址是四个字节，取两次
    39                                  	
    40                                  	
    41                                  	;汇编代码中，从内存取数据的时候，是ds:偏移地址取值，段内代码跳转的时候是cs:偏移地址 。
    42                                  	;为了获得正确的段内偏移地址
    43                                  	;读programer程序的大小，因为是32位，读两次
    44                                  	;现在dx:ax是program初始CodeSeg地址，下面将重新计算
    45                                  	
    46                                  		
    47 0000002C 50                      	push ax
    48 0000002D 52                      	push dx
    49 0000002E 2EA1[B600]              	mov ax,cs:DESTMEM
    50 00000032 2E8B16[B800]            	mov dx,cs:DESTMEM+2
    51 00000037 5A                      	pop dx
    52 00000038 58                      	pop ax
    53                                  	
    54 00000039 2E0306[B600]            	add ax,[cs:DESTMEM]  ; cs:0xffff,内存值0x0000，前面取出了ax，将两者相加
    55 0000003E 2E1316[B800]            	adc dx,[cs:DESTMEM+2] ;内存值0x0001
    56 00000043 BE1000                  	mov si,16 ;0x0001_0020  >> 16  =  0x1002
    57 00000046 F7F6                    	div si
    58 00000048 8907                    	mov [bx],ax ;新的地址计算完成,重写到[0x04]处
    59                                  	
    60                                  	
    61                                  	
    62 0000004A 83C304                  	add bx,4 ;准备计算下一个
    63 0000004D E2D8                    	loop .reset
    64                                  	
    65                                  	ResetEntry:
    66 0000004F A11300                  	mov ax,[0x13] ;ax，所以取了13、14
    67 00000052 8B161500                	mov dx,[0x15] 
    68                                  
    69                                  	
    70 00000056 2E0306[B600]            	add ax,[cs:DESTMEM] ; 
    71 0000005B 2E0316[B800]            	add dx,[cs:DESTMEM+2] ;
    72 00000060 BE1000                  	mov si,16
    73 00000063 F7F6                    	div si  	;shr ax,4
    74                                  	
    75 00000065 A31300                  	mov [0x13],ax
    76                                  	
    77 00000068 FF2E1100                	jmp far [0x11] ;jmp far [address] 是通过该内存地址处的 4 字节（16位 offset + 16位 segment）作为目标。
    78                                  					;DESTMEM:0x11是入口地址
    79                                  	
    80                                  READHDD:
    81 0000006C 50                      	push ax
    82 0000006D 53                      	push bx
    83 0000006E 51                      	push cx
    84 0000006F 52                      	push dx
    85 00000070 BAF201                  	mov dx,HDDPORT+2
    86 00000073 EE                      	out dx,al ;al存储的扇区数,写到dx端口
    87                                  	
    88 00000074 BAF301                  	mov dx,HDDPORT+3 ;开始写地址
    89 00000077 89F0                    	mov ax,si ;lba28低位si写到ax
    90 00000079 EE                      	out dx,al ;写低位 0-7
    91                                  
    92 0000007A BAF401                  	mov dx,HDDPORT+4
    93 0000007D 88E0                    	mov al,ah
    94 0000007F EE                      	out dx,al ;写高位 8-15
    95                                  	
    96 00000080 BAF501                  	mov dx,HDDPORT+5
    97 00000083 89C8                    	mov ax,cx ;换一个寄存器赋值到ax,写低位 16-23
    98 00000085 EE                      	out dx,al
    99                                  	
   100 00000086 BAF601                  	mov dx,HDDPORT+6
   101 00000089 88E0                    	mov al,ah
   102 0000008B B4E0                    	mov ah,0xe0 ;采用lba模式读取
   103 0000008D 08E0                    	or al,ah
   104 0000008F EE                      	out dx,al ;写24-27位
   105                                  	
   106 00000090 BAF701                  	mov dx,HDDPORT+7
   107 00000093 B020                    	mov al,0x20 ;0x20为读模式,0x30为写模式
   108 00000095 EE                      	out dx,al
   109                                  	
   110                                  	.waits: ;自旋锁循环等待磁盘io可用
   111 00000096 EC                      	in al,dx
   112 00000097 2488                    	and al,0x88
   113 00000099 3C08                    	cmp al,0x08
   114 0000009B 75F9                    	jnz .waits
   115                                  	
   116 0000009D BAF001                  	mov dx, HDDPORT ;地址写完,dx挪作hddport使用
   117 000000A0 B90001                  	mov cx,256 ;每次可以读2字节，所以循环256读取一个扇区
   118                                  	
   119                                  	.readword:
   120 000000A3 ED                      	in ax,dx ;读取端口数据到ax
   121 000000A4 3E8905                  	mov [ds:di],ax ;存到内存
   122 000000A7 83C702                  	add di,2
   123                                  	;or ah,0x00 ;因为数据以0x00结尾，所以看到0x00就退出
   124                                  	;jnz .readword
   125 000000AA E2F7                    	loop .readword
   126                                  	.return:
   127 000000AC 5A                      	pop dx
   128 000000AD 59                      	pop cx
   129 000000AE 5B                      	pop bx
   130 000000AF 58                      	pop ax
   131 000000B0 C3                      	ret
   132                                  	
   133                                  	
   134                                  
   135 000000B1 01000000                READSTART  dd 1
   136 000000B5 01                      SECTORNUM  db 1
   137 000000B6 00000100                DESTMEM	   dd 0x10000
   138                                  
   139 000000BA EBFE                    End: jmp End
   140                                  ;msg db 'mbr load secucess,loading next sector... ',0
   141 000000BC 00<rep 142h>            times 510-($-$$) db 0 ; 填充剩余空间
   142 000001FE 55AA                    dw 0xAA55
