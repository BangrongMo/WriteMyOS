     1                                  HDDPORT equ 0x1f0
     2                                  section code align=16 vstart=0x7c00
     3 00000000 8B36[A400]              mov si,[READSTART]
     4 00000004 8B0E[A600]              mov cx,[READSTART+0X02] ;存储lba28地址,需要四个字节,高位cx低位si
     5 00000008 A0[A800]                mov al,[SECTORNUM];要读入的扇区数量
     6 0000000B 50                      push ax ;保存扇区值al,push 要用ax，所以一起ah保存了
     7                                  
     8 0000000C A1[A900]                mov ax,[DESTMEM]
     9 0000000F 8B16[AB00]              mov dx,[DESTMEM+0X02]
    10 00000013 BB1000                  mov bx,16 ;因为DESTMEM是完整地址，除以16计算DESTMEM的段地址
    11 00000016 F7F3                    div bx
    12                                  
    13 00000018 8ED8                    mov ds,ax ;配置段地址
    14 0000001A 31FF                    xor di,di ;偏移地址置0
    15 0000001C 58                      pop ax
    16                                  
    17                                  ;mov si, msg
    18                                  
    19 0000001D E83F00                  call READHDD
    20                                  
    21                                  
    22                                  ;加载完program.bin后，里面编译好的段地址和偏移地址是不能直接用的，
    23                                  ;因为编译器是按照program作为第一个扇区的程序来设置地址的
    24                                  ;而bootloader实际上才是第一个扇区的，所以要重新计算program的段地址和偏移地址，
    25                                  ;并修改加载到内存的program，才能跳转到program执行
    26                                  ;mov ax, [1000h] 默认等价于 mov ax, [ds:1000h]
    27                                  ;jmp 1234h 那么跳转目标是 CS:1234h，在当前代码段中跳转。
    28                                  
    29                                  
    30                                  ResetSegment: ;？修改段地址到0x1000,即第二个扇区读入到内存的地址
    31 00000020 BB0400                  	mov bx,0x04 ;将program段地址所在的内存地址写入bx,地址来源于program.asm中CodeSeg dd section.code.start
    32 00000023 8A0E1000                	mov cl,[0x10] ;0x10地址存储了program有多少个段,方便后面作为循环次数 ds本来以及指向DESTMEM，所以直接取
    33                                  	
    34                                  	.reset:	
    35                                  	
    36 00000027 8B07                    	mov ax,[bx] ;取出段地址（其实是相对地址，[bx]存储的值是编译program.asm产生的，
    37                                  				;是独立的,之后和bootloader整合就要重新计算段和偏移）
    38 00000029 8B5702                  	mov dx,[bx+2]  ;由于地址是四个字节，取两次
    39                                  	
    40                                  	
    41                                  	;汇编代码中，从内存取数据的时候，是ds:偏移地址取值，段内代码跳转的时候是cs:偏移地址 。
    42                                  	;为了获得正确的段内偏移地址
    43                                  	;读programer程序的大小，因为是32位，读两次
    44                                  	;现在dx:ax是program初始CodeSeg地址，下面将重新计算
    45                                  	
    46 0000002C 2E0306[A900]            	add ax,[cs:DESTMEM]  ; cs:0xffff,内存值0x0000，前面取出了ax，将两者相加
    47 00000031 2E1316[AB00]            	adc dx,[cs:DESTMEM+2] ;内存值0x0001
    48 00000036 BE1000                  	mov si,16 ;0x0001_0020  >> 16  =  0x1002
    49 00000039 F7F6                    	div si
    50 0000003B 8907                    	mov [bx],ax ;新的地址计算完成,重写到[0x04]处
    51                                  	
    52                                  	
    53                                  	
    54 0000003D 83C304                  	add bx,4 ;准备计算下一个
    55 00000040 E2E5                    	loop .reset
    56                                  	
    57                                  	ResetEntry:
    58 00000042 A11300                  	mov ax,[0x13] ;ax，所以取了13、14
    59 00000045 8B161500                	mov dx,[0x15] 
    60 00000049 2E0306[A900]            	add ax,[cs:DESTMEM] ; 
    61 0000004E 2E0316[AB00]            	add dx,[cs:DESTMEM+2] ;
    62 00000053 BE1000                  	mov si,16
    63 00000056 F7F6                    	div si  	;shr ax,4
    64                                  	
    65 00000058 A31300                  	mov [0x13],ax
    66                                  	
    67 0000005B FF2E1100                	jmp far [0x11] ;jmp far [address] 是通过该内存地址处的 4 字节（16位 offset + 16位 segment）作为目标。
    68                                  					;DESTMEM:0x11是入口地址
    69                                  	
    70                                  READHDD:
    71 0000005F 50                      	push ax
    72 00000060 53                      	push bx
    73 00000061 51                      	push cx
    74 00000062 52                      	push dx
    75 00000063 BAF201                  	mov dx,HDDPORT+2
    76 00000066 EE                      	out dx,al ;al存储的扇区数,写到dx端口
    77                                  	
    78 00000067 BAF301                  	mov dx,HDDPORT+3 ;开始写地址
    79 0000006A 89F0                    	mov ax,si ;lba28低位si写到ax
    80 0000006C EE                      	out dx,al ;写低位 0-7
    81                                  
    82 0000006D BAF401                  	mov dx,HDDPORT+4
    83 00000070 88E0                    	mov al,ah
    84 00000072 EE                      	out dx,al ;写高位 8-15
    85                                  	
    86 00000073 BAF501                  	mov dx,HDDPORT+5
    87 00000076 89C8                    	mov ax,cx ;换一个寄存器赋值到ax,写低位 16-23
    88 00000078 EE                      	out dx,al
    89                                  	
    90 00000079 BAF601                  	mov dx,HDDPORT+6
    91 0000007C 88E0                    	mov al,ah
    92 0000007E B4E0                    	mov ah,0xe0 ;采用lba模式读取
    93 00000080 08E0                    	or al,ah
    94 00000082 EE                      	out dx,al ;写24-27位
    95                                  	
    96 00000083 BAF701                  	mov dx,HDDPORT+7
    97 00000086 B020                    	mov al,0x20 ;0x20为读模式,0x30为写模式
    98 00000088 EE                      	out dx,al
    99                                  	
   100                                  	.waits: ;自旋锁循环等待磁盘io可用
   101 00000089 EC                      	in al,dx
   102 0000008A 2488                    	and al,0x88
   103 0000008C 3C08                    	cmp al,0x08
   104 0000008E 75F9                    	jnz .waits
   105                                  	
   106 00000090 BAF001                  	mov dx, HDDPORT ;地址写完,dx挪作hddport使用
   107 00000093 B90001                  	mov cx,256 ;每次可以读2字节，所以循环256读取一个扇区
   108                                  	
   109                                  	.readword:
   110 00000096 ED                      	in ax,dx ;读取端口数据到ax
   111 00000097 3E8905                  	mov [ds:di],ax ;存到内存
   112 0000009A 83C702                  	add di,2
   113                                  	;or ah,0x00 ;因为数据以0x00结尾，所以看到0x00就退出
   114                                  	;jnz .readword
   115 0000009D E2F7                    	loop .readword
   116                                  	.return:
   117 0000009F 5A                      	pop dx
   118 000000A0 59                      	pop cx
   119 000000A1 5B                      	pop bx
   120 000000A2 58                      	pop ax
   121 000000A3 C3                      	ret
   122                                  	
   123                                  	
   124                                  
   125 000000A4 01000000                READSTART  dd 1
   126 000000A8 01                      SECTORNUM  db 1
   127 000000A9 00000100                DESTMEM	   dd 0x10000
   128                                  
   129 000000AD EBFE                    End: jmp End
   130                                  ;msg db 'mbr load secucess,loading next sector... ',0
   131 000000AF 00<rep 14Fh>            times 510-($-$$) db 0 ; 填充剩余空间
   132 000001FE 55AA                    dw 0xAA55
